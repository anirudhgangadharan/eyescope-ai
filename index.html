<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1565C0">
    <title>EyeScopeAI - Vision Screening</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        :root {
            --primary: #1565C0;
            --primary-dark: #0D47A1;
            --accent: #FF6F00;
            --success: #4CAF50;
            --error: #F44336;
            --gray: #9E9E9E;
            --gray-light: #F5F5F5;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: white;
            min-height: 100vh;
            overflow-x: hidden;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .screen {
            display: none;
            width: 100%;
            min-height: 100vh;
            flex-direction: column;
        }
        
        .screen.active {
            display: flex;
        }
        
        /* Home Screen */
        #homeScreen {
            justify-content: center;
            align-items: center;
            padding: 24px;
            text-align: center;
        }
        
        .logo { font-size: 72px; margin-bottom: 16px; }
        
        .title {
            font-size: 32px;
            font-weight: bold;
            color: var(--primary-dark);
            margin-bottom: 8px;
        }
        
        .subtitle {
            font-size: 16px;
            color: var(--gray);
            margin-bottom: 24px;
        }
        
        .calibration-status {
            font-size: 14px;
            padding: 8px 16px;
            border-radius: 20px;
            margin-bottom: 24px;
        }
        
        .calibration-status.calibrated {
            background: #E8F5E9;
            color: var(--success);
        }
        
        .calibration-status.not-calibrated {
            background: #FFF3E0;
            color: var(--accent);
        }
        
        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            width: 100%;
            max-width: 400px;
            text-align: left;
        }
        
        .card h3 {
            color: var(--primary);
            margin-bottom: 12px;
            font-size: 18px;
        }
        
        .card p, .card li {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
        }
        
        .card ol { padding-left: 20px; }
        
        .input-group {
            width: 100%;
            max-width: 400px;
            margin-bottom: 24px;
        }
        
        .input-group label {
            display: block;
            font-size: 14px;
            color: var(--gray);
            margin-bottom: 8px;
        }
        
        .input-group input {
            width: 100%;
            padding: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        .input-group input:focus { border-color: var(--primary); }
        .input-group input.required-field { border-color: var(--error); }
        
        .btn {
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
            width: 100%;
            max-width: 400px;
            margin-bottom: 12px;
        }
        
        .btn:active { transform: scale(0.98); }
        .btn-primary { background: var(--primary); color: white; }
        .btn-accent { background: var(--accent); color: white; }
        .btn-success { background: var(--success); color: white; }
        .btn-outline { background: white; color: var(--primary); border: 2px solid var(--primary); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-small { padding: 12px 24px; font-size: 16px; }
        
        .version {
            font-size: 12px;
            color: var(--gray);
            margin-top: 24px;
        }
        
        .sync-status {
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 12px;
            margin-top: 8px;
        }
        
        .sync-status.online { background: #E8F5E9; color: var(--success); }
        .sync-status.offline { background: #FFF3E0; color: var(--accent); }
        
        /* Calibration Screen */
        #calibrationScreen {
            justify-content: center;
            align-items: center;
            padding: 24px;
            text-align: center;
        }
        
        .calibration-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-dark);
            margin-bottom: 8px;
        }
        
        .calibration-instruction {
            font-size: 16px;
            color: var(--gray);
            margin-bottom: 24px;
            max-width: 320px;
        }
        
        .calibration-box-container {
            position: relative;
            margin: 24px 0;
        }
        
        .calibration-box {
            border: 3px solid var(--primary);
            background: rgba(21, 101, 192, 0.1);
            transition: width 0.1s, height 0.1s;
        }
        
        .calibration-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: var(--primary-dark);
            font-weight: bold;
        }
        
        .calibration-controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            align-items: center;
        }
        
        .calibration-controls button {
            width: 60px;
            height: 60px;
            font-size: 32px;
            border-radius: 50%;
            border: 2px solid var(--primary);
            background: white;
            color: var(--primary);
            cursor: pointer;
        }
        
        .calibration-controls button:active {
            background: var(--primary);
            color: white;
        }
        
        .calibration-size {
            font-size: 18px;
            color: var(--primary-dark);
            min-width: 80px;
        }
        
        .calibration-hint {
            font-size: 12px;
            color: var(--gray);
            margin-bottom: 24px;
        }
        
        /* Distance Screen */
        #distanceScreen {
            justify-content: center;
            align-items: center;
            padding: 24px;
            text-align: center;
            background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
        }
        
        .distance-icon {
            font-size: 80px;
            margin-bottom: 24px;
        }
        
        .distance-title {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary-dark);
            margin-bottom: 16px;
        }
        
        .distance-value {
            font-size: 72px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
        }
        
        .distance-instruction {
            font-size: 18px;
            color: #333;
            margin-bottom: 32px;
            max-width: 320px;
            line-height: 1.6;
        }
        
        .distance-tips {
            background: white;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 32px;
            max-width: 320px;
            text-align: left;
        }
        
        .distance-tips h4 {
            color: var(--primary);
            margin-bottom: 8px;
        }
        
        .distance-tips li {
            font-size: 14px;
            margin-bottom: 4px;
            color: #333;
        }
        
        /* Test Screen */
        #testScreen { background: white; }
        
        .test-header {
            background: var(--primary);
            color: white;
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .eye-indicator { font-size: 18px; font-weight: bold; }
        .progress-text { font-size: 14px; opacity: 0.9; }
        
        .acuity-display {
            background: var(--gray-light);
            padding: 8px;
            text-align: center;
            font-size: 12px;
            color: var(--gray);
        }
        
        .test-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            min-height: 60vh;
            touch-action: none;
        }
        
        .tumbling-e {
            font-family: 'Arial Black', 'Arial', sans-serif;
            font-weight: 900;
            color: black;
            transition: transform 0.1s;
            line-height: 1;
        }
        
        .direction-hint {
            position: absolute;
            font-size: 24px;
            opacity: 0.3;
            color: var(--gray);
        }
        
        .hint-up { top: 20px; left: 50%; transform: translateX(-50%); }
        .hint-down { bottom: 100px; left: 50%; transform: translateX(-50%); }
        .hint-left { left: 20px; top: 50%; transform: translateY(-50%); }
        .hint-right { right: 20px; top: 50%; transform: translateY(-50%); }
        
        .instructions-bar {
            background: var(--gray-light);
            padding: 16px;
            text-align: center;
            font-size: 16px;
            color: var(--gray);
        }
        
        .feedback-bar {
            height: 8px;
            background: var(--gray-light);
            transition: background-color 0.2s;
        }
        
        .feedback-bar.correct { background: var(--success); }
        .feedback-bar.incorrect { background: var(--error); }
        
        /* Results Screen */
        #resultsScreen {
            justify-content: center;
            align-items: center;
            padding: 24px;
            overflow-y: auto;
        }
        
        .check-icon { font-size: 64px; color: var(--success); margin-bottom: 16px; }
        
        .results-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 400px;
            margin-bottom: 24px;
        }
        
        .results-card h2 {
            color: var(--primary);
            margin-bottom: 16px;
            font-size: 20px;
        }
        
        .subject-id-display {
            font-size: 14px;
            color: var(--gray);
            margin-bottom: 16px;
        }
        
        .eye-result {
            background: var(--gray-light);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
        }
        
        .eye-result h4 {
            color: var(--primary-dark);
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .eye-result p { font-size: 16px; margin: 4px 0; }
        .eye-result .decimal { font-size: 14px; color: var(--gray); }
        .timestamp { font-size: 12px; color: var(--gray); margin-top: 16px; }
        
        .btn-group { width: 100%; max-width: 400px; }
        .btn-group .btn { margin-bottom: 12px; }
        
        .save-status {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
        }
        
        .save-status.saving { background: #E3F2FD; color: var(--primary); }
        .save-status.saved { background: #E8F5E9; color: var(--success); }
        .save-status.error { background: #FFEBEE; color: var(--error); }
        .save-status.queued { background: #FFF3E0; color: var(--accent); }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal.active { display: flex; }
        
        .modal-content {
            background: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 320px;
            text-align: center;
        }
        
        .modal-content h3 { color: var(--primary-dark); margin-bottom: 16px; }
        .modal-content p { margin-bottom: 20px; line-height: 1.6; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .processing { animation: pulse 0.5s ease-in-out; }
        
        .pending-badge {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--accent);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            display: none;
            z-index: 100;
        }
        
        .pending-badge.show { display: block; }
    </style>
</head>
<body>
    <div id="pendingBadge" class="pending-badge"></div>

    <!-- Home Screen -->
    <div id="homeScreen" class="screen active">
        <div class="logo">üëÅÔ∏è</div>
        <div class="title">EyeScopeAI</div>
        <div class="subtitle">Vision Screening Tool</div>
        
        <div id="calibrationStatus" class="calibration-status not-calibrated">
            ‚ö†Ô∏è Screen not calibrated
        </div>
        
        <div class="card">
            <h3>üìã Instructions</h3>
            <ol>
                <li>Calibrate screen first (one-time)</li>
                <li>Hold phone at 40cm distance</li>
                <li>Cover one eye</li>
                <li>Swipe direction the E points</li>
            </ol>
        </div>
        
        <div class="input-group">
            <label for="subjectId">Subject ID <strong style="color: var(--error);">*</strong></label>
            <input type="text" id="subjectId" placeholder="Enter Subject ID (required)">
        </div>
        
        <button class="btn btn-primary" onclick="startTest()">Start Vision Test</button>
        <button class="btn btn-outline" onclick="showCalibration()">üìê Calibrate Screen</button>
        
        <div class="version">v1.2.0 | ICMR STS 2025</div>
        <div id="syncStatus" class="sync-status online">‚óè Online</div>
    </div>
    
    <!-- Calibration Screen -->
    <div id="calibrationScreen" class="screen">
        <div class="calibration-title">üìê Screen Calibration</div>
        <div class="calibration-instruction">
            Place your <strong>3cm √ó 3cm</strong> card on the box below and adjust until it matches exactly.
        </div>
        
        <div class="calibration-box-container">
            <div id="calibrationBox" class="calibration-box"></div>
            <div class="calibration-label">3 √ó 3 cm</div>
        </div>
        
        <div class="calibration-controls">
            <button onclick="adjustCalibration(-5)">‚àí</button>
            <div class="calibration-size" id="calibrationSize">100 px</div>
            <button onclick="adjustCalibration(5)">+</button>
        </div>
        
        <div class="calibration-hint">
            Adjust until the box matches your card perfectly
        </div>
        
        <button class="btn btn-success" onclick="saveCalibration()">‚úì Done - Save Calibration</button>
        <button class="btn btn-outline btn-small" onclick="showScreen('home')">Cancel</button>
    </div>
    
    <!-- Distance Instruction Screen -->
    <div id="distanceScreen" class="screen">
        <div class="distance-icon">üìè</div>
        <div class="distance-title">Testing Distance</div>
        <div class="distance-value">40 cm</div>
        <div class="distance-instruction">
            Hold the phone at <strong>arm's length</strong> (40cm from eyes). Use a string or ruler to measure.
        </div>
        
        <div class="distance-tips">
            <h4>üí° Tips</h4>
            <ul>
                <li>Keep phone still during test</li>
                <li>Ensure good lighting</li>
                <li>Cover one eye completely</li>
                <li>No squinting allowed</li>
            </ul>
        </div>
        
        <button class="btn btn-primary" onclick="beginTest()">I'm Ready - Start Test</button>
    </div>
    
    <!-- Test Screen -->
    <div id="testScreen" class="screen">
        <div class="test-header">
            <span class="eye-indicator" id="eyeIndicator">Right Eye (OD)</span>
            <span class="progress-text" id="progressText">Line 1/11 | Trial 1/3</span>
        </div>
        
        <div class="acuity-display" id="acuityDisplay">
            LogMAR: 1.0 | Snellen: 6/60
        </div>
        
        <div class="test-area" id="testArea">
            <span class="direction-hint hint-up">‚Üë</span>
            <span class="direction-hint hint-down">‚Üì</span>
            <span class="direction-hint hint-left">‚Üê</span>
            <span class="direction-hint hint-right">‚Üí</span>
            <div class="tumbling-e" id="tumblingE">E</div>
        </div>
        
        <div class="instructions-bar">Swipe in the direction the E is pointing</div>
        <div class="feedback-bar" id="feedbackBar"></div>
    </div>
    
    <!-- Results Screen -->
    <div id="resultsScreen" class="screen">
        <div class="check-icon">‚úì</div>
        <div class="title">Test Complete</div>
        
        <div id="saveStatus" class="save-status saving">‚è≥ Saving to database...</div>
        
        <div class="results-card">
            <h2>Your Results</h2>
            <div class="subject-id-display" id="subjectIdDisplay">Subject ID: ---</div>
            
            <div class="eye-result">
                <h4>Right Eye (OD)</h4>
                <p id="rightLogMAR">LogMAR: ---</p>
                <p id="rightSnellen">Snellen: ---</p>
                <p class="decimal" id="rightDecimal">Decimal VA: ---</p>
            </div>
            
            <div class="eye-result">
                <h4>Left Eye (OS)</h4>
                <p id="leftLogMAR">LogMAR: ---</p>
                <p id="leftSnellen">Snellen: ---</p>
                <p class="decimal" id="leftDecimal">Decimal VA: ---</p>
            </div>
            
            <div class="timestamp" id="timestamp">Tested: ---</div>
        </div>
        
        <div class="btn-group">
            <button class="btn btn-success" onclick="restartTest()">‚úì Next Patient</button>
            <button class="btn btn-primary" onclick="retrySync()" id="retryBtn" style="display:none;">‚Üª Retry Upload</button>
            <button class="btn btn-accent" onclick="shareResults()">Share Results</button>
        </div>
    </div>
    
    <!-- Eye Transition Modal -->
    <div id="transitionModal" class="modal">
        <div class="modal-content">
            <h3>Right Eye Complete</h3>
            <p id="transitionMessage">Now cover your RIGHT eye for LEFT eye test.</p>
            <button class="btn btn-primary" onclick="continueToLeftEye()">Continue</button>
        </div>
    </div>

    <script>
        // =====================================================
        // EyeScopeAI v1.2.0
        // With Calibration & Proper Optotype Sizing
        // =====================================================
        
        const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbyPQ_ajsygSEIVsVcl_oRTij7iXISbeRc-BPUt3se5or8vFNeuwQ60g9IE1NQ8W1dcrqw/exec';
        const STORAGE_KEY = 'eyescopeai_pending';
        const CALIBRATION_KEY = 'eyescopeai_calibration';
        
        // Test Configuration
        const CONFIG = {
            MAX_WRONG_CONSECUTIVE: 2,
            TRIALS_PER_LINE: 3,
            MIN_CORRECT_TO_PASS: 2,
            FEEDBACK_DELAY: 400,
            SWIPE_THRESHOLD: 50,
            TEST_DISTANCE_CM: 40,
            CALIBRATION_CARD_CM: 3
        };
        
        // LogMAR Scale (11 lines: 1.0 to 0.0)
        // Optotype size in mm at 40cm for each LogMAR level
        // Formula: size = 5 * tan(5 * 10^LogMAR * œÄ / 10800) * distance * 10
        // At LogMAR 1.0, 40cm: ~29.1mm (for 5 strokes)
        // At LogMAR 0.0, 40cm: ~2.91mm
        const LOGMAR_VALUES = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0];
        const SNELLEN_VALUES = ['6/60', '6/48', '6/38', '6/30', '6/24', '6/19', '6/15', '6/12', '6/9.5', '6/7.5', '6/6'];
        
        // Optotype HEIGHT in mm at 40cm distance for each LogMAR level
        // LogMAR 1.0 = 29.1mm, each step down = divide by 1.2589
        const OPTOTYPE_SIZE_MM = [
            29.1,   // LogMAR 1.0
            23.1,   // LogMAR 0.9
            18.4,   // LogMAR 0.8
            14.6,   // LogMAR 0.7
            11.6,   // LogMAR 0.6
            9.2,    // LogMAR 0.5
            7.3,    // LogMAR 0.4
            5.8,    // LogMAR 0.3
            4.6,    // LogMAR 0.2
            3.7,    // LogMAR 0.1
            2.9     // LogMAR 0.0
        ];
        
        const DIRECTIONS = { RIGHT: 0, UP: 90, LEFT: 180, DOWN: 270 };
        const DIR_ARRAY = [0, 90, 180, 270];
        
        // Calibration State
        let calibration = {
            pixelsPerCm: null,
            calibrationBoxPx: 100,
            deviceModel: navigator.userAgent,
            calibratedAt: null
        };
        
        // Test State
        let state = {
            subjectId: '',
            isRightEye: true,
            currentLine: 0,
            trialOnLine: 0,
            correctOnLine: 0,
            consecutiveWrong: 0,
            currentDirection: 0,
            rightEyeLogMAR: -1,
            leftEyeLogMAR: -1,
            isProcessing: false,
            testStartTime: null
        };
        
        let touchStartX = 0, touchStartY = 0;
        
        // DOM Elements
        const screens = {
            home: document.getElementById('homeScreen'),
            calibration: document.getElementById('calibrationScreen'),
            distance: document.getElementById('distanceScreen'),
            test: document.getElementById('testScreen'),
            results: document.getElementById('resultsScreen')
        };
        
        const elements = {
            subjectIdInput: document.getElementById('subjectId'),
            calibrationStatus: document.getElementById('calibrationStatus'),
            calibrationBox: document.getElementById('calibrationBox'),
            calibrationSize: document.getElementById('calibrationSize'),
            eyeIndicator: document.getElementById('eyeIndicator'),
            progressText: document.getElementById('progressText'),
            acuityDisplay: document.getElementById('acuityDisplay'),
            testArea: document.getElementById('testArea'),
            tumblingE: document.getElementById('tumblingE'),
            feedbackBar: document.getElementById('feedbackBar'),
            transitionModal: document.getElementById('transitionModal'),
            transitionMessage: document.getElementById('transitionMessage'),
            saveStatus: document.getElementById('saveStatus'),
            retryBtn: document.getElementById('retryBtn'),
            syncStatus: document.getElementById('syncStatus'),
            pendingBadge: document.getElementById('pendingBadge')
        };
        
        // =====================================================
        // Calibration Functions
        // =====================================================
        
        function loadCalibration() {
            try {
                const saved = localStorage.getItem(CALIBRATION_KEY);
                if (saved) {
                    calibration = JSON.parse(saved);
                    updateCalibrationStatus();
                    return true;
                }
            } catch (e) {
                console.error('Error loading calibration:', e);
            }
            return false;
        }
        
        function saveCalibration() {
            // Calculate pixels per cm based on box size
            calibration.pixelsPerCm = calibration.calibrationBoxPx / CONFIG.CALIBRATION_CARD_CM;
            calibration.calibratedAt = new Date().toISOString();
            calibration.deviceModel = navigator.userAgent;
            
            localStorage.setItem(CALIBRATION_KEY, JSON.stringify(calibration));
            updateCalibrationStatus();
            showScreen('home');
            
            console.log('Calibration saved:', calibration.pixelsPerCm, 'px/cm');
        }
        
        function updateCalibrationStatus() {
            if (calibration.pixelsPerCm) {
                elements.calibrationStatus.className = 'calibration-status calibrated';
                elements.calibrationStatus.textContent = `‚úì Calibrated (${calibration.pixelsPerCm.toFixed(1)} px/cm)`;
            } else {
                elements.calibrationStatus.className = 'calibration-status not-calibrated';
                elements.calibrationStatus.textContent = '‚ö†Ô∏è Screen not calibrated';
            }
        }
        
        function showCalibration() {
            showScreen('calibration');
            updateCalibrationBox();
        }
        
        function adjustCalibration(delta) {
            calibration.calibrationBoxPx = Math.max(50, Math.min(300, calibration.calibrationBoxPx + delta));
            updateCalibrationBox();
        }
        
        function updateCalibrationBox() {
            const size = calibration.calibrationBoxPx;
            elements.calibrationBox.style.width = size + 'px';
            elements.calibrationBox.style.height = size + 'px';
            elements.calibrationSize.textContent = size + ' px';
        }
        
        // =====================================================
        // Screen Management
        // =====================================================
        
        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            screens[screenName].classList.add('active');
        }
        
        function showModal(show) {
            elements.transitionModal.classList.toggle('active', show);
        }
        
        // =====================================================
        // Test Flow
        // =====================================================
        
        function startTest() {
            const subjectId = elements.subjectIdInput.value.trim();
            
            if (!subjectId) {
                elements.subjectIdInput.classList.add('required-field');
                elements.subjectIdInput.focus();
                alert('Please enter Subject ID');
                return;
            }
            
            if (!calibration.pixelsPerCm) {
                if (!confirm('Screen not calibrated. Results may be inaccurate. Continue anyway?')) {
                    showCalibration();
                    return;
                }
                // Use default estimate (assume ~38 px/cm for typical phones)
                calibration.pixelsPerCm = 38;
            }
            
            elements.subjectIdInput.classList.remove('required-field');
            state.subjectId = subjectId;
            state.testStartTime = new Date();
            
            // Show distance instruction
            showScreen('distance');
        }
        
        function beginTest() {
            resetTestState();
            state.isRightEye = true;
            
            showScreen('test');
            setupTouchListeners();
            presentNextTrial();
        }
        
        function resetTestState() {
            state.currentLine = 0;
            state.trialOnLine = 0;
            state.correctOnLine = 0;
            state.consecutiveWrong = 0;
            state.isProcessing = false;
        }
        
        function continueToLeftEye() {
            showModal(false);
            state.isRightEye = false;
            resetTestState();
            presentNextTrial();
        }
        
        function restartTest() {
            state.rightEyeLogMAR = -1;
            state.leftEyeLogMAR = -1;
            elements.subjectIdInput.value = '';
            showScreen('home');
        }
        
        // =====================================================
        // Optotype Sizing (Calibrated)
        // =====================================================
        
        function getOptotypeSizePx(lineIndex) {
            const sizeMm = OPTOTYPE_SIZE_MM[lineIndex];
            const sizeCm = sizeMm / 10;
            const sizePx = sizeCm * calibration.pixelsPerCm;
            return sizePx;
        }
        
        // =====================================================
        // Trial Presentation
        // =====================================================
        
        function presentNextTrial() {
            elements.eyeIndicator.textContent = state.isRightEye ? 'Right Eye (OD)' : 'Left Eye (OS)';
            elements.progressText.textContent = `Line ${state.currentLine + 1}/${LOGMAR_VALUES.length} | Trial ${state.trialOnLine + 1}/${CONFIG.TRIALS_PER_LINE}`;
            
            const currentLogMAR = LOGMAR_VALUES[state.currentLine];
            elements.acuityDisplay.textContent = `LogMAR: ${currentLogMAR.toFixed(1)} | Snellen: ${SNELLEN_VALUES[state.currentLine]}`;
            
            state.currentDirection = DIR_ARRAY[Math.floor(Math.random() * 4)];
            
            // Get calibrated size
            const sizePx = getOptotypeSizePx(state.currentLine);
            
            elements.tumblingE.style.fontSize = sizePx + 'px';
            elements.tumblingE.style.transform = `rotate(${-state.currentDirection}deg)`;
            
            elements.feedbackBar.className = 'feedback-bar';
        }
        
        // =====================================================
        // Touch/Swipe Detection
        // =====================================================
        
        let touchListenersAdded = false;
        
        function setupTouchListeners() {
            if (touchListenersAdded) return;
            touchListenersAdded = true;
            
            const testArea = elements.testArea;
            testArea.addEventListener('touchstart', handleTouchStart, { passive: true });
            testArea.addEventListener('touchend', handleTouchEnd, { passive: true });
            testArea.addEventListener('mousedown', handleMouseDown);
            testArea.addEventListener('mouseup', handleMouseUp);
        }
        
        function handleTouchStart(e) {
            if (state.isProcessing) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }
        
        function handleTouchEnd(e) {
            if (state.isProcessing) return;
            processSwipe(e.changedTouches[0].clientX - touchStartX, e.changedTouches[0].clientY - touchStartY);
        }
        
        function handleMouseDown(e) {
            if (state.isProcessing) return;
            touchStartX = e.clientX;
            touchStartY = e.clientY;
        }
        
        function handleMouseUp(e) {
            if (state.isProcessing) return;
            processSwipe(e.clientX - touchStartX, e.clientY - touchStartY);
        }
        
        function processSwipe(diffX, diffY) {
            const absX = Math.abs(diffX), absY = Math.abs(diffY);
            if (Math.max(absX, absY) < CONFIG.SWIPE_THRESHOLD) return;
            
            let swipeDirection;
            if (absX > absY) {
                swipeDirection = diffX > 0 ? DIRECTIONS.RIGHT : DIRECTIONS.LEFT;
            } else {
                swipeDirection = diffY > 0 ? DIRECTIONS.DOWN : DIRECTIONS.UP;
            }
            processResponse(swipeDirection);
        }
        
        // =====================================================
        // Response Processing
        // =====================================================
        
        function processResponse(userDirection) {
            state.isProcessing = true;
            const isCorrect = (userDirection === state.currentDirection);
            
            elements.feedbackBar.className = 'feedback-bar ' + (isCorrect ? 'correct' : 'incorrect');
            elements.tumblingE.classList.add('processing');
            
            if (isCorrect) {
                state.correctOnLine++;
                state.consecutiveWrong = 0;
            } else {
                state.consecutiveWrong++;
            }
            
            state.trialOnLine++;
            
            if (state.consecutiveWrong >= CONFIG.MAX_WRONG_CONSECUTIVE && state.currentLine > 0) {
                finishCurrentEye(state.currentLine - 1);
                return;
            }
            
            if (state.trialOnLine >= CONFIG.TRIALS_PER_LINE) {
                if (state.correctOnLine >= CONFIG.MIN_CORRECT_TO_PASS) {
                    state.currentLine++;
                    if (state.currentLine >= LOGMAR_VALUES.length) {
                        finishCurrentEye(LOGMAR_VALUES.length - 1);
                        return;
                    }
                } else {
                    finishCurrentEye(state.currentLine > 0 ? state.currentLine - 1 : 0);
                    return;
                }
                state.trialOnLine = 0;
                state.correctOnLine = 0;
            }
            
            setTimeout(() => {
                state.isProcessing = false;
                elements.tumblingE.classList.remove('processing');
                presentNextTrial();
            }, CONFIG.FEEDBACK_DELAY);
        }
        
        // =====================================================
        // Test Completion
        // =====================================================
        
        function finishCurrentEye(finalLine) {
            const logMAR = LOGMAR_VALUES[finalLine];
            
            if (state.isRightEye) {
                state.rightEyeLogMAR = logMAR;
                setTimeout(() => {
                    elements.transitionMessage.innerHTML = 
                        `Right Eye: <strong>${SNELLEN_VALUES[finalLine]}</strong> (LogMAR ${logMAR.toFixed(1)})<br><br>` +
                        `Now cover your <strong>RIGHT</strong> eye for <strong>LEFT</strong> eye test.`;
                    showModal(true);
                }, CONFIG.FEEDBACK_DELAY);
            } else {
                state.leftEyeLogMAR = logMAR;
                showResultsAndSave();
            }
        }
        
        // =====================================================
        // Data & Backend
        // =====================================================
        
        function buildResultData() {
            const rightLine = getLineFromLogMAR(state.rightEyeLogMAR);
            const leftLine = getLineFromLogMAR(state.leftEyeLogMAR);
            
            return {
                timestamp: new Date().toISOString(),
                subject_id: state.subjectId,
                right_eye_logmar: state.rightEyeLogMAR.toFixed(1),
                right_eye_snellen: SNELLEN_VALUES[rightLine],
                right_eye_decimal: Math.pow(10, -state.rightEyeLogMAR).toFixed(2),
                left_eye_logmar: state.leftEyeLogMAR.toFixed(1),
                left_eye_snellen: SNELLEN_VALUES[leftLine],
                left_eye_decimal: Math.pow(10, -state.leftEyeLogMAR).toFixed(2),
                test_distance_cm: CONFIG.TEST_DISTANCE_CM,
                screen_ppi: calibration.pixelsPerCm ? (calibration.pixelsPerCm * 2.54).toFixed(1) : 'uncalibrated',
                device_info: navigator.userAgent.substring(0, 100)
            };
        }
        
        function getLineFromLogMAR(logMAR) {
            for (let i = 0; i < LOGMAR_VALUES.length; i++) {
                if (Math.abs(LOGMAR_VALUES[i] - logMAR) < 0.05) return i;
            }
            return 0;
        }
        
        // =====================================================
        // Backend Sync
        // =====================================================
        
        function updateOnlineStatus() {
            const isOnline = navigator.onLine;
            elements.syncStatus.className = 'sync-status ' + (isOnline ? 'online' : 'offline');
            elements.syncStatus.textContent = isOnline ? '‚óè Online' : '‚óè Offline';
            if (isOnline) syncPendingData();
        }
        
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        
        function getPendingData() {
            try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); }
            catch { return []; }
        }
        
        function savePendingData(data) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            updatePendingBadge();
        }
        
        function updatePendingBadge() {
            const pending = getPendingData();
            if (pending.length > 0) {
                elements.pendingBadge.textContent = `${pending.length} pending`;
                elements.pendingBadge.classList.add('show');
            } else {
                elements.pendingBadge.classList.remove('show');
            }
        }
        
        async function saveToBackend(data) {
            elements.saveStatus.className = 'save-status saving';
            elements.saveStatus.textContent = '‚è≥ Saving...';
            elements.retryBtn.style.display = 'none';
            
            const pending = getPendingData();
            const dataWithId = { ...data, _tempId: Date.now() };
            pending.push(dataWithId);
            savePendingData(pending);
            
            if (!navigator.onLine) {
                elements.saveStatus.className = 'save-status queued';
                elements.saveStatus.textContent = 'üì± Saved offline';
                return;
            }
            
            try {
                await fetch(BACKEND_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                const updatedPending = getPendingData().filter(d => d._tempId !== dataWithId._tempId);
                savePendingData(updatedPending);
                
                elements.saveStatus.className = 'save-status saved';
                elements.saveStatus.textContent = '‚úì Saved';
            } catch (error) {
                console.error('Save error:', error);
                elements.saveStatus.className = 'save-status error';
                elements.saveStatus.textContent = '‚ö† Save failed - stored locally';
                elements.retryBtn.style.display = 'block';
            }
        }
        
        async function syncPendingData() {
            const pending = getPendingData();
            if (pending.length === 0) return;
            
            for (const data of pending) {
                try {
                    await fetch(BACKEND_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    
                    const updated = getPendingData().filter(d => d._tempId !== data._tempId);
                    savePendingData(updated);
                } catch (error) {
                    break;
                }
            }
            updatePendingBadge();
        }
        
        function retrySync() {
            if (navigator.onLine) {
                syncPendingData();
                saveToBackend(buildResultData());
            } else {
                alert('Still offline. Data saved locally.');
            }
        }
        
        // =====================================================
        // Results Display
        // =====================================================
        
        function showResultsAndSave() {
            showScreen('results');
            
            document.getElementById('subjectIdDisplay').textContent = `Subject ID: ${state.subjectId}`;
            
            if (state.rightEyeLogMAR >= 0) {
                const rightLine = getLineFromLogMAR(state.rightEyeLogMAR);
                document.getElementById('rightLogMAR').textContent = `LogMAR: ${state.rightEyeLogMAR.toFixed(1)}`;
                document.getElementById('rightSnellen').textContent = `Snellen: ${SNELLEN_VALUES[rightLine]}`;
                document.getElementById('rightDecimal').textContent = `Decimal VA: ${Math.pow(10, -state.rightEyeLogMAR).toFixed(2)}`;
            }
            
            if (state.leftEyeLogMAR >= 0) {
                const leftLine = getLineFromLogMAR(state.leftEyeLogMAR);
                document.getElementById('leftLogMAR').textContent = `LogMAR: ${state.leftEyeLogMAR.toFixed(1)}`;
                document.getElementById('leftSnellen').textContent = `Snellen: ${SNELLEN_VALUES[leftLine]}`;
                document.getElementById('leftDecimal').textContent = `Decimal VA: ${Math.pow(10, -state.leftEyeLogMAR).toFixed(2)}`;
            }
            
            document.getElementById('timestamp').textContent = `Tested: ${new Date().toLocaleString()}`;
            
            saveToBackend(buildResultData());
        }
        
        // =====================================================
        // Share
        // =====================================================
        
        function shareResults() {
            const rightLine = getLineFromLogMAR(state.rightEyeLogMAR);
            const leftLine = getLineFromLogMAR(state.leftEyeLogMAR);
            
            const shareText = `EyeScopeAI Results
Subject: ${state.subjectId}
Date: ${new Date().toLocaleString()}

OD (Right): ${SNELLEN_VALUES[rightLine]} | LogMAR ${state.rightEyeLogMAR.toFixed(1)}
OS (Left): ${SNELLEN_VALUES[leftLine]} | LogMAR ${state.leftEyeLogMAR.toFixed(1)}

Distance: ${CONFIG.TEST_DISTANCE_CM}cm | Calibrated: ${calibration.pixelsPerCm ? 'Yes' : 'No'}`;
            
            if (navigator.share) {
                navigator.share({ title: 'EyeScopeAI', text: shareText }).catch(console.error);
            } else {
                navigator.clipboard.writeText(shareText).then(() => alert('Copied!')).catch(() => alert(shareText));
            }
        }
        
        // =====================================================
        // Init
        // =====================================================
        
        loadCalibration();
        updateOnlineStatus();
        updatePendingBadge();
        updateCalibrationBox();
        if (navigator.onLine) syncPendingData();
        
        window.addEventListener('beforeunload', (e) => {
            if (screens.test.classList.contains('active')) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        
        document.addEventListener('dblclick', (e) => e.preventDefault());
        
        console.log('EyeScopeAI v1.2.0 - Calibrated Vision Screening');
    </script>
</body>
</html>
